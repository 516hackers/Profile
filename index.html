<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>516 Hackers — Advanced 3D Landing (Enhanced)</title>

<!-- GSAP + ScrollTrigger (CDN) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>

<!-- Three.js (non-module bundle) -->
<script src="https://unpkg.com/three@0.156.0/build/three.min.js"></script>

<style>
  :root{
    --bg:#05060a; --neon:#00ff88; --accent:#8affff; --muted:#889;
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#020205 0%, #060814 100%);color:#e6eef8;overflow-x:hidden;}
  a{color:var(--neon);text-decoration:none}
  .wrap{max-width:1200px;margin:0 auto;padding:40px 24px;position:relative;z-index:6}
  header{display:flex;align-items:center;justify-content:space-between;gap:16px}
  .logo{display:flex;align-items:center;gap:12px}
  .mark{width:48px;height:48px;border-radius:8px;background:linear-gradient(135deg,#002b1f,#003f2f);display:flex;align-items:center;justify-content:center;font-weight:700;color:var(--neon)}
  nav a{margin-left:18px;color:#9fbfbd;font-size:14px}
  section{min-height:100vh;padding:110px 0;position:relative;display:flex;align-items:center}
  .section-inner{display:grid;grid-template-columns:1fr 460px;gap:40px;align-items:center}
  .left{max-width:720px}
  .eyebrow{color:var(--muted);font-size:13px;letter-spacing:1px;text-transform:uppercase}
  h1{font-size:44px;line-height:1.02;margin:10px 0;color:#dfffe8}
  p.lead{color:#b7dcca;font-size:18px;line-height:1.5}
  .card{background:rgba(255,255,255,0.02);backdrop-filter:blur(6px);padding:18px;border-radius:12px;border:1px solid rgba(0,255,136,0.04)}
  .btn{display:inline-block;padding:10px 18px;border-radius:10px;background:linear-gradient(90deg,var(--neon),var(--accent));color:#041014;font-weight:700;margin-top:14px;text-decoration:none}
  #glCanvas{position:fixed;inset:0;width:100%;height:100%;z-index:1;pointer-events:none}
  footer{padding:28px 24px;text-align:center;color:var(--muted);font-size:13px}
  .section-label{position:absolute;left:18px;top:18px;font-size:11px;color:rgba(255,255,255,0.04)}
  @media (max-width:980px){
    .section-inner{grid-template-columns:1fr;gap:24px}
    .right{order:-1}
    h1{font-size:32px}
  }
  /* WebGL fallback message */
  #no-webgl {display:none;position:fixed;inset:0;background:#000a;color:#fff;z-index:9999;align-items:center;justify-content:center;padding:20px;text-align:center}
  #no-webgl.visible{display:flex}
</style>
</head>
<body>
  <div id="no-webgl" role="alert" aria-live="assertive">
    <div>
      <h2>WebGL not available</h2>
      <p>Your browser does not support WebGL or it is disabled. The site uses WebGL for advanced 3D effects. Please try a modern browser (Chrome/Edge/Firefox) or enable hardware acceleration.</p>
    </div>
  </div>

  <canvas id="glCanvas" aria-hidden="true"></canvas>

  <div class="wrap" style="position:relative;z-index:6">
    <header>
      <div class="logo"><div class="mark">516</div>
        <div>
          <div style="font-weight:700">516 Hackers</div>
          <div style="font-size:12px;color:var(--muted)">Breaking the matrix — ethically</div>
        </div>
      </div>
      <nav>
        <a href="#about">About</a>
        <a href="#features">Tools</a>
        <a href="#community">Community</a>
        <a href="#vault">Join</a>
      </nav>
    </header>
  </div>

  <!-- Sections -->
  <section id="hero">
    <div class="section-label">Hero — Gateway</div>
    <div class="wrap section-inner">
      <div class="left">
        <div class="eyebrow">Welcome</div>
        <h1>Enter the network — <span style="color:var(--neon)">516 Hackers</span></h1>
        <p class="lead">Immersive lab: interactive tutorials, real-time sandboxes, and community challenges. Scroll to unlock 3D worlds.</p>
        <a class="btn" href="#vault">Unlock the Vault</a>
      </div>
      <div class="right card">
        <strong>Live:</strong> Matrix Globe · Particles · Glitch preview
        <div style="height:10px"></div>
        <div style="font-size:13px;color:var(--muted)">Tip: For best results, use a desktop GPU. On mobile, animations are simplified.</div>
      </div>
    </div>
  </section>

  <section id="about">
    <div class="section-label">About — Code in Motion</div>
    <div class="wrap section-inner">
      <div class="left">
        <div class="eyebrow">About</div>
        <h1>Code as art — <span style="color:var(--neon)">motion & meaning</span></h1>
        <p class="lead">Lines of code rearrange into symbols. Learn the craft behind ethical hacking and visualization.</p>
      </div>
      <div class="right card">
        <strong>Preview:</strong> Animated ribbons · Glyphs
      </div>
    </div>
  </section>

  <section id="features">
    <div class="section-label">Features — Tools Lab</div>
    <div class="wrap section-inner">
      <div class="left">
        <div class="eyebrow">Tools</div>
        <h1>Labs & Tools — <span style="color:var(--neon)">interactive</span></h1>
        <p class="lead">Pentest sandboxes, AI analytics, and secure server racks — each tool becomes a 3D object you inspect as you scroll.</p>
      </div>
      <div class="right card">
        <strong>Try:</strong> Click the preview button
        <div style="height:10px"></div>
        <button class="btn" id="openTool">Open Tool Preview</button>
      </div>
    </div>
  </section>

  <section id="community">
    <div class="section-label">Community — Network Graph</div>
    <div class="wrap section-inner">
      <div class="left">
        <div class="eyebrow">Community</div>
        <h1>Nodes & Connections — <span style="color:var(--neon)">collaborate</span></h1>
        <p class="lead">A dynamic 3D network lights up as members join. Hover nodes to see anonymized profiles (demo).</p>
      </div>
      <div class="right card">
        <strong>Network:</strong> Live graph · Join counters
      </div>
    </div>
  </section>

  <section id="vault">
    <div class="section-label">Vault — CTA</div>
    <div class="wrap section-inner">
      <div class="left">
        <div class="eyebrow">Join Us</div>
        <h1>Open the <span style="color:var(--neon)">Hacker Vault</span></h1>
        <p class="lead">Unlock challenges, labs and mentorship. The vault opens as you arrive — watch it rotate and reveal the CTA.</p>
        <a class="btn" href="#join">Join 516</a>
      </div>
      <div class="right card">
        <strong>Vault Status:</strong> Standby — scroll to open.
      </div>
    </div>
  </section>

  <footer>
    © 516 Hackers • Ethical learning • Built with Three.js + GSAP
  </footer>

  <!-- Script: enhanced Three.js + GSAP integration -->
  <script>
  (function(){
    'use strict';
    // === Basic feature detection ===
    function webglAvailable(){
      try {
        const canvas = document.createElement('canvas');
        return !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
      } catch(e){ return false; }
    }
    if(!webglAvailable()){
      document.getElementById('no-webgl').classList.add('visible');
      // Don't run the rest
      return;
    }

    // === Globals & feature flags ===
    const canvas = document.getElementById('glCanvas');
    const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true, powerPreference: 'high-performance'});
    const DPR = Math.min(window.devicePixelRatio || 1, 2);
    renderer.setPixelRatio(DPR);
    renderer.setSize(window.innerWidth, window.innerHeight, false);
    renderer.outputEncoding = THREE.sRGBEncoding;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x00070a);
    scene.fog = new THREE.FogExp2(0x00060a, 0.0007);

    const camera = new THREE.PerspectiveCamera(48, window.innerWidth / window.innerHeight, 0.1, 4000);
    camera.position.set(0, 22, 160);

    // Maintain a camera target vector and update camera.lookAt(cameraTarget) each frame.
    const cameraTarget = new THREE.Vector3(0, 0, 0);

    // Lights
    const hemi = new THREE.HemisphereLight(0x88ffdd, 0x001a22, 0.7);
    scene.add(hemi);
    const point = new THREE.PointLight(0x00ff88, 0.9, 800);
    point.position.set(50, 80, 120);
    scene.add(point);

    // Groups (one per section) — kept in world space (we move the camera to "focus")
    const groups = {
      hero: new THREE.Group(),
      about: new THREE.Group(),
      features: new THREE.Group(),
      community: new THREE.Group(),
      vault: new THREE.Group()
    };
    scene.add(groups.hero, groups.about, groups.features, groups.community, groups.vault);

    // Device detection: reduce detail on mobile/low-power
    const isMobile = /Mobi|Android/i.test(navigator.userAgent) || window.innerWidth < 900;
    const PARTICLE_COUNT = isMobile ? 400 : 1200; // tuned
    const SPARSE_COUNT = isMobile ? 40 : 60;

    // Utility: safe requestAnimationFrame loop control
    let running = true;
    function startLoop(){ running = true; animate(); }
    function stopLoop(){ running = false; }

    // Resize handling (debounced)
    let resizeTimeout = null;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(()=> {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      }, 120);
    });

    // Pause rendering when page hidden (saves CPU & battery)
    document.addEventListener('visibilitychange', () => {
      if(document.hidden) stopLoop();
      else startLoop();
    });

    // ---------- HERO: globe + streaming particles ----------
    (function createHero(){
      const g = groups.hero;

      // Globe (smooth low-poly-ish icosahedron)
      const globeGeo = new THREE.IcosahedronGeometry(36, 5);
      const globeMat = new THREE.MeshStandardMaterial({
        color: 0x003f2f, metalness: 0.25, roughness: 0.2, emissive: 0x002a1a, transparent: true, opacity: 0.98
      });
      const globe = new THREE.Mesh(globeGeo, globeMat);
      globe.castShadow = false;
      globe.receiveShadow = false;
      g.add(globe);

      // Wireframe overlay (thin lines)
      const lineMat = new THREE.LineBasicMaterial({color:0x00ff88, transparent:true, opacity:0.22});
      const wire = new THREE.LineSegments(new THREE.WireframeGeometry(globeGeo), lineMat);
      wire.scale.multiplyScalar(1.006);
      g.add(wire);

      // Streaming particles around globe (BufferGeometry)
      const pGeo = new THREE.BufferGeometry();
      const positions = new Float32Array(PARTICLE_COUNT * 3);
      const radii = new Float32Array(PARTICLE_COUNT); // allow per-particle radius for variety
      for(let i=0;i<PARTICLE_COUNT;i++){
        const theta = Math.random()*Math.PI*2;
        const phi = Math.acos(2*Math.random()-1);
        const r = 40 + Math.random()*80;
        positions[i*3]   = Math.sin(phi)*Math.cos(theta)*r;
        positions[i*3+1] = Math.sin(phi)*Math.sin(theta)*r*0.5;
        positions[i*3+2] = Math.cos(phi)*r;
        radii[i] = 0.6 + Math.random()*1.6;
      }
      pGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      pGeo.setAttribute('r', new THREE.BufferAttribute(radii, 1));
      const pMat = new THREE.PointsMaterial({size: isMobile ? 1.1 : 1.8, transparent:true, opacity:0.95});
      const particles = new THREE.Points(pGeo, pMat);
      particles.frustumCulled = false;
      g.add(particles);

      g.position.set(-20, -5, -40);
      g.userData = {globe, wire, particles, particlePositions: positions};
      // Continuous slow globe spin
      gsap.to(globe.rotation, {y:Math.PI*2, duration:40, repeat:-1, ease:'none'});
    })();

    // ---------- ABOUT: ribbons / glyphs (lightweight) ----------
    (function createAbout(){
      const g = groups.about;

      // create simple ribbons using CanvasTexture for gradient look
      function createRibbon(i){
        const canvas = document.createElement('canvas');
        canvas.width = 256; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        const c1 = i % 2 ? '#002b1f' : '#003f2f';
        const c2 = i % 2 ? '#00ff88' : '#88fff0';
        const grad = ctx.createLinearGradient(0,0,canvas.width,0);
        grad.addColorStop(0, c1);
        grad.addColorStop(1, c2);
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.globalAlpha = 0.08;
        ctx.fillStyle = '#000';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        const tex = new THREE.CanvasTexture(canvas);
        tex.encoding = THREE.sRGBEncoding;
        const mat = new THREE.MeshBasicMaterial({map:tex, transparent:true, opacity:0.9, side: THREE.DoubleSide});
        const mesh = new THREE.Mesh(new THREE.PlaneGeometry(36, 6), mat);
        return mesh;
      }

      for(let i=0;i<22;i++){
        const r = createRibbon(i);
        const a = i * 0.25;
        r.position.set(Math.cos(a)*40, (i-10)*1.6, Math.sin(a)*40);
        r.rotation.y = a + Math.PI/2;
        g.add(r);
      }

      // simple central glyph with boxes
      const boxGeo = new THREE.BoxGeometry(6, 18, 1.6);
      const boxMat = new THREE.MeshStandardMaterial({color:0x00ff88, emissive:0x003322, roughness:0.22});
      for(let i=0;i<5;i++){
        const b = new THREE.Mesh(boxGeo, boxMat);
        b.position.set((i-2)*9, 0, 0);
        g.add(b);
      }

      g.position.set(10,-12,-120);
      // tiny rotation
      gsap.to(g.rotation, {y:0.6, duration:20, repeat:-1, yoyo:true, ease:'sine.inOut'});
    })();

    // ---------- FEATURES: stylized server & laptop planes ----------
    (function createFeatures(){
      const g = groups.features;

      // create a server-like tower
      function tower(x,y,z){
        const geo = new THREE.CylinderGeometry(8.5,10,36,16);
        const mat = new THREE.MeshStandardMaterial({color:0x004d3a, metalness:0.7, roughness:0.15, emissive:0x001a0f});
        const m = new THREE.Mesh(geo, mat);
        m.position.set(x,y,z);
        g.add(m);
        // small "indicator lights" as small boxes
        for(let i=0;i<5;i++){
          const light = new THREE.Mesh(new THREE.BoxGeometry(2,0.9,0.6), new THREE.MeshBasicMaterial({color:0x00ff88}));
          light.position.set(x + (Math.random()*4-2), y - 10 + i*4.5, z+6);
          g.add(light);
        }
      }
      tower(-18,0,-60);
      tower(28,10,-38);

      const plane = new THREE.Mesh(new THREE.BoxGeometry(32,18,2), new THREE.MeshStandardMaterial({color:0x003a2d, metalness:0.3, roughness:0.3}));
      plane.position.set(0,-6,-18);
      plane.rotation.x = 0.12;
      g.add(plane);

      // ring highlight
      const ringGeo = new THREE.TorusGeometry(34,0.9,12,120);
      const ring = new THREE.Mesh(ringGeo, new THREE.MeshBasicMaterial({color:0x00ff88, transparent:true, opacity:0.12}));
      ring.rotation.x = Math.PI/2;
      ring.position.set(0,-6,-18);
      ring.name = 'featuresRing';
      g.add(ring);

      g.position.set(-10, -2, -140);
      gsap.to(g.rotation, {y:Math.PI*2, duration:70, repeat:-1, ease:'none'});
    })();

    // ---------- COMMUNITY: node graph ----------
    (function createCommunity(){
      const g = groups.community;
      const nodes = [];
      const nodeGeo = new THREE.SphereGeometry(isMobile?1.4:1.8, 8, 8);
      const nodeMat = new THREE.MeshBasicMaterial({color:0x00ff88});
      const nodeCount = isMobile ? 38 : 60;
      for(let i=0;i<nodeCount;i++){
        const n = new THREE.Mesh(nodeGeo, nodeMat);
        const theta = Math.random()*Math.PI*2;
        const phi = (Math.random()*Math.PI)-Math.PI/2;
        const r = 50 + Math.random()*70;
        n.position.set(Math.cos(theta)*Math.cos(phi)*r, Math.sin(phi)*r*0.6, Math.sin(theta)*Math.cos(phi)*r);
        nodes.push(n); g.add(n);
      }
      // edges (sparse)
      const lineMat = new THREE.LineBasicMaterial({color:0x007f5a, transparent:true, opacity:0.12});
      for(let i=0;i<SPARSE_COUNT;i++){
        const a = nodes[Math.floor(Math.random()*nodes.length)].position;
        const b = nodes[Math.floor(Math.random()*nodes.length)].position;
        const geo = new THREE.BufferGeometry().setFromPoints([a,b]);
        const line = new THREE.Line(geo, lineMat);
        g.add(line);
      }

      // pulsate nodes for "join" effect
      nodes.forEach((n, idx)=>{
        const delay = Math.random()*6;
        gsap.to(n.scale, {x:1.6,y:1.6,z:1.6, duration:0.8, repeat:-1, yoyo:true, ease:'sine.inOut', delay});
      });

      g.position.set(0,-18,-200);
    })();

    // ---------- VAULT: rotating door ----------
    (function createVault(){
      const g = groups.vault;
      const ring = new THREE.Mesh(new THREE.TorusGeometry(80,8,24,120), new THREE.MeshStandardMaterial({color:0x003f2f, metalness:0.95, roughness:0.2, emissive:0x001a13}));
      ring.name = 'vaultRing';
      g.add(ring);

      // spokes
      const spokeGeo = new THREE.BoxGeometry(4,120,6);
      const spokeMat = new THREE.MeshStandardMaterial({color:0x00ff88, emissive:0x003322, roughness:0.28});
      for(let i=0;i<6;i++){
        const s = new THREE.Mesh(spokeGeo, spokeMat);
        s.rotation.z = (i/6)*Math.PI*2;
        s.position.set(0,0,0);
        g.add(s);
      }

      const lock = new THREE.Mesh(new THREE.CylinderGeometry(12,12,8,36), new THREE.MeshStandardMaterial({color:0x00ff88, metalness:0.8}));
      lock.position.set(0,0,4);
      lock.name = 'vaultLock';
      g.add(lock);

      g.position.set(0,-10,-250);
    })();

    // Give initial visibility so groups exist in scene — camera moves to focus on them
    groups.hero.visible = groups.about.visible = groups.features.visible = groups.community.visible = groups.vault.visible = true;

    // === Camera & animation helpers ===
    // Smoothly change camera position and cameraTarget (used for lookAt)
    function focusOn(group, opts = {}){
      // Compute a sensible focus point from group's world position
      const pos = new THREE.Vector3();
      group.getWorldPosition(pos);
      const offset = opts.offset || new THREE.Vector3(0, 18, 160);
      const targetPos = new THREE.Vector3().copy(pos).add(opts.targetOffset || new THREE.Vector3(0,0,0));

      // Animate camera position
      gsap.to(camera.position, {duration: Math.min(opts.duration || 1.2, 2.2), x: pos.x + offset.x, y: pos.y + offset.y, z: pos.z + offset.z, ease:'power3.out'});

      // Animate cameraTarget vector, which we apply in render loop
      gsap.to(cameraTarget, {duration: Math.min(opts.duration || 1.2, 2.2), x: targetPos.x, y: targetPos.y, z: targetPos.z, ease:'power3.out'});
    }

    // Vault open animation
    function openVault(){
      // rotate vault group around Z
      gsap.to(groups.vault.rotation, {z: Math.PI*1.05, duration:2.6, ease:'power2.out'});
      // camera dip for dramatics
      gsap.to(camera.position, {duration:1.6, x:0, y:-10, z:40, ease:'power2.out'});
      gsap.to(camera.position, {duration:1.6, delay:1.6, x:0, y:10, z:160, ease:'power2.inOut'});
      // flash lock material (if present)
      const lock = groups.vault.getObjectByName('vaultLock');
      if(lock && lock.material){
        gsap.fromTo(lock.material, {emissiveIntensity:0.1}, {emissiveIntensity:1.6, duration:0.22, yoyo:true, repeat:6});
      }
    }

    // Set up ScrollTrigger interactions (maps DOM sections to camera focuses)
    gsap.registerPlugin(ScrollTrigger);
    const sectionMap = [
      {id:'hero',    onEnter: ()=> focusOn(groups.hero, {offset:new THREE.Vector3(-20, 18, 80)})},
      {id:'about',   onEnter: ()=> focusOn(groups.about, {offset:new THREE.Vector3(10, 18, 120)})},
      {id:'features',onEnter: ()=> focusOn(groups.features, {offset:new THREE.Vector3(-12, 8, 120)})},
      {id:'community',onEnter: ()=> focusOn(groups.community, {offset:new THREE.Vector3(0, 18, 220), targetOffset: new THREE.Vector3(0, -8, -60)})},
      {id:'vault',   onEnter: ()=> openVault()}
    ];
    sectionMap.forEach(s => {
      ScrollTrigger.create({
        trigger: '#' + s.id,
        start: 'top center',
        end: 'bottom center',
        onEnter: s.onEnter,
        onEnterBack: s.onEnter
      });
    });

    // Button: open tool preview (features zoom)
    document.getElementById('openTool').addEventListener('click', (e) => {
      e.preventDefault();
      focusOn(groups.features, {offset:new THREE.Vector3(-10, 8, 70), duration:0.9});
      const ring = groups.features.getObjectByName('featuresRing');
      if(ring && ring.material){
        gsap.to(ring.material, {duration:0.7, opacity:0.55, yoyo:true, repeat:3});
      }
    });

    // Pointer parallax (desktop only) — moves camera slightly (no canvas pointer capture)
    let mouse = {x:0, y:0};
    if(!isMobile){
      window.addEventListener('mousemove', (ev)=>{
        mouse.x = (ev.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(ev.clientY / window.innerHeight) * 2 + 1;
        // smooth camera small offset using gsap to avoid abrupt jumps
        gsap.to(camera.position, {duration:1.0, x: mouse.x * 14, y: 10 + mouse.y * 12, ease:'power3.out'});
      }, {passive:true});
    }

    // === Animation loop ===
    const clock = new THREE.Clock();
    function animate(){
      if(!running) return;
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime();

      // Hero particle subtle motion: move a little along z based on sin, but minimize array writes
      const heroData = groups.hero.userData;
      if(heroData && heroData.particles && heroData.particlePositions){
        // only update a sample each frame to reduce CPU on mobile
        const pos = heroData.particles.geometry.attributes.position;
        const arr = pos.array;
        const stride = 3;
        // we update every Nth particle each frame to distribute work across frames
        const step = isMobile ? 6 : 2;
        for(let i=0;i<arr.length;i+=stride*step){
          // small circular wobble
          arr[i+2] += Math.sin((i + t*40) * 0.00035) * 0.18;
        }
        pos.needsUpdate = true;
      }

      // subtle rotations of groups
      groups.hero.rotation.y += 0.002 * (isMobile ? 0.6 : 1.0);
      groups.about.rotation.y += 0.0012;
      groups.features.rotation.y += 0.0009;
      groups.community.rotation.y += 0.00045;

      // smoothly lookAt cameraTarget each frame
      camera.lookAt(cameraTarget.x, cameraTarget.y, cameraTarget.z);

      renderer.render(scene, camera);
    }
    startLoop();

    // Clean up on page unload — avoids lingering RAF in SPA-like usage
    window.addEventListener('beforeunload', () => {
      stopLoop();
      renderer.forceContextLoss && renderer.forceContextLoss();
    });

    // ===== Debug helpers (disabled in production) =====
    // Uncomment to enable ScrollTrigger markers:
    // ScrollTrigger.defaults({markers:true});

    // ===== End core script =====
  })();
  </script>
</body>
</html>
